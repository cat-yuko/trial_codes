WebGL2 にはジオメトリシェーダーがありません。 なので “GS でエッジ生成” は不可。

代わりに、インスタンシング + カスタムシェーダーで“各エッジを 1 インスタンスとして描く”方式なら、GPU側で視点依存のシルエット判定を実装できます（WebGL2 + gl_VertexID を活用）。

あなたの要件（球は外周、立方体や円柱は稜線＋外周）を満たすために、以下をやりました：

CPUは一度だけメッシュから「共有エッジ」＋「各エッジが接する2面の法線」を構築（ローカル空間）。

GPU（Vertex/Fragment）で毎フレーム、

カメラ方向との向き判定（表裏）

法線の直交 or 90°超の鋭角

境界エッジ
を組み合わせてシルエット可視を決める。

ハードエッジも**角度しきい値（UIのThreshold）**で同じパス内に統合。

キャンバスに、WebGL2 + ShaderMaterial 版の完全コードを置きました（Next.js App Routerでそのまま動かせる単一コンポーネント）。
ファイル名の例：GLBShaderSilhouetteEdges.tsx として使ってください。

ポイント（実装メモ）：

エッジ1本 = 1インスタンス。instanceP1/P2（端点）、instanceN1/N2（隣接面法線）、instanceHasN2（境界フラグ）を InstancedBufferAttribute で供給。

頂点シェーダで gl_VertexID を使って P1/P2 を出力。中点での視点ベクトルと法線から可視判定を行い、vVisible でフラグを渡してフラグメントで discard。

ハードエッジは dot(n1,n2) <= cos(threshold) で可視化。UIの「Hard Edges」「Silhouette」チェックで独立にON/OFF。

行列更新：各メッシュの matrixWorld/normalMatrix を毎フレーム uniforms に更新するので、モデルが動いてもOK。

太線：WebGLの lineWidth は環境依存なのでいまは1px。太線が必要なら**画面空間ビルボード（エッジをクアッドで描く）**方式に拡張できます（必要なら続編で入れます）。

気になる点があれば：

複数マテリアル/スキニング/モーフ対応 → 追加情報をインスタンス属性やテクスチャで拡張すればOK。

巨大モデルでの初回エッジ構築のコスト → 現在CPUで一度だけ。必要ならワーカー化やインデックス／隣接生成のストリーミングも可能。
